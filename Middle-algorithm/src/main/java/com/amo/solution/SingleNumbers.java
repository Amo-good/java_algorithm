package com.amo.solution;

/**
 * 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。
 * 请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
 * 输入：nums = [4,1,4,6]
 * 输出：[1,6] 或 [6,1]
 */
public class SingleNumbers {
    /**
     * 第一轮整体遍历，求出x^y（因为相同的数字异或为0，0异或任何数字为数字自身）
     * 然后结合x^y以及原来数组求出这两个数字
     * 原理：用一个只有一位为1的数字来遍历异或整个数组，把这个数组分成两个子数组（异或结果相同的数字在同一个子数组），
     * 如果是两个相同的数字，它们一定在同一个子数组里（保证子数组异或时为0），现在只需要把两个只出现一次的数字分到不同的子数组，
     * 那么子数组分别遍历异或得到的两个数字就是这两个数字。
     * 怎么把两个只出现一次的数字分到不同地子数组？
     * 找到x^y第一个为1的位置，异或结果为1说明x和y在这一位上不同，那用只有这一位为1的数字m去分别异或x和y，得到的结果一定不同，
     * 也就把x和y分到了不同的子数组。结合上一点得出结果。
     * （在一个if中，无论与m与上多少次，最终都会得到只出现一次的值，因为m不仅区分了两个不同的唯一出现数，而且对于出现两次的数，它们一定会都进入这次if，最终被异或得0）
     */
    public int[] singleNumbers(int[] nums) {
        int x = 0, y = 0, n = 0, m = 1;
        //求出x^y的值
        for (int num : nums) {
            n^=num;
        }
        //求出第一个x^y的第一个为1的数
        while ((n&m)==0){
            m<<=1;//m左移
        }
        //再次遍历数组，将两个数划分为不同的子数组，再分对子数组异或的结果即为不同的两个数
        for (int num : nums) {
            //如果m=0010  那么只有第二位数为1的值&出来的值才会等于m 其余的值都会0
            if ((num&m)==0) x^=num;  //划分x  相同的数一定会划分在一块
            else y^=num; //划分y
        }
        return new int[]{x,y};
    }

}
